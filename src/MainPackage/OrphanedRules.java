/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package MainPackage;

import BCLibrary.StoreBasic;
import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.TimeUnit;
import javax.swing.JEditorPane;
import javax.swing.JProgressBar;
import javax.swing.SwingWorker;
import org.json.JSONArray;
import org.json.JSONObject;

/**
 *
 * @author julio
 */
public class OrphanedRules extends javax.swing.JInternalFrame {

    private StoreBasic store;
    private EscalationsDesktop desktop;
    private Thread newThread;
    private Thread apiLimitThread;
    private int rulesCount;
    private int productsCount;
    private int percentage;
    private int totalRules;
    private String timer;
    private String currentTask;
    private Connection database;
    private Statement statement;
    private PreparedStatement preparedStatement;
    
    class ProgressThread implements Runnable {
        private boolean alive;
        private JProgressBar threadBar;
        private boolean isTimerAvailable;
        
        ProgressThread (JProgressBar bar) {
            this.alive = true;
            this.threadBar = bar;
            this.threadBar.setValue(0);
            this.threadBar.setStringPainted(true);
            timer = "unknown";
            this.isTimerAvailable = false;
        }
        ProgressThread (JProgressBar bar, boolean isTimerAvailable) {
            this.alive = true;
            this.threadBar = bar;
            this.threadBar.setValue(0);
            this.threadBar.setStringPainted(true);
            this.isTimerAvailable = true;
            timer = "unknown";
        }
        public void run() {
            while(alive) {
                threadBar.setValue(percentage);
                if (!isTimerAvailable)
                    threadBar.setString(currentTask + " " + percentage + "%");
                else
                    threadBar.setString(currentTask + " " + percentage + "%" + " (Estimated Time: " + timer + ")");
                try {
                    Thread.sleep(3);
                } catch (InterruptedException ex) {
                    
                }
                if (percentage == 100) {
                    threadBar.setValue(100);
                    threadBar.setString(currentTask + " " + percentage + "%");
                    alive = false;
                }
            }
        }
        public void toggle(String choice) {
            if (choice.equalsIgnoreCase("on"))
                alive = true;
            else
                alive = false;
        }
    }
    
    class UpdateThread implements Runnable {
        private JEditorPane pane;
        private boolean alive;
     
        UpdateThread(JEditorPane pane) {
            alive = true;
            this.pane = pane;
        }
        public void run() {
            while(alive) {
                pane.setText("Connected: Yes\n" + "API Limit: " + store.getAPILimit());
                try {
                    Thread.sleep(2);
                } catch (InterruptedException ex) {
                    
                }
                if (percentage == 100)
                    alive = false;
            }
        }
        public void toggle(String choice) {
            if (choice.equalsIgnoreCase("on"))
                alive = true;
            else
                alive = false;
        }
    }
    
    public OrphanedRules() {
        initComponents();
    }
    
     public OrphanedRules(StoreBasic store, EscalationsDesktop desktop) throws SQLException {
        this.store = store;
        this.desktop = desktop;
        this.rulesCount = 0;
        this.productsCount = 0;
        this.percentage = 0;
        this.database = desktop.getDBConnection();
        this.statement = database.createStatement();
        this.database.setAutoCommit(false);
        this.preparedStatement = null;
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        orphanedRulesProgress = new javax.swing.JProgressBar();
        orphanedRulesLabel = new javax.swing.JLabel();
        orphanedRulesCheck = new javax.swing.JButton();
        orphanedRulesFix = new javax.swing.JButton();

        setClosable(true);
        setDefaultCloseOperation(javax.swing.WindowConstants.HIDE_ON_CLOSE);
        setTitle("Orphaned Rules");

        orphanedRulesLabel.setText("Results posted here...");
        orphanedRulesLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        orphanedRulesCheck.setText("Check");
        orphanedRulesCheck.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                orphanedRulesCheckActionPerformed(evt);
            }
        });

        orphanedRulesFix.setText("Fix");
        orphanedRulesFix.setEnabled(false);
        orphanedRulesFix.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                orphanedRulesFixActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(orphanedRulesProgress, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(orphanedRulesLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 305, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 38, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(orphanedRulesFix, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(orphanedRulesCheck, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 108, Short.MAX_VALUE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(orphanedRulesCheck)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(orphanedRulesFix)
                        .addGap(35, 35, 35))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(4, 4, 4)
                        .addComponent(orphanedRulesLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                .addComponent(orphanedRulesProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void orphanedRulesCheckActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_orphanedRulesCheckActionPerformed
        SwingWorker <Void, Void> worker = new SwingWorker<Void, Void>() {
        @Override
            protected Void doInBackground() throws Exception {
                int jsonArrayLength = 0;
                int page = 1;
                String results;
                JSONArray jsonArray;
                JSONObject jsonObject;
                orphanedRulesCheck.setEnabled(false);
                statement.executeUpdate("DELETE FROM allProducts");
                statement.executeUpdate("DELETE FROM allRules");
                try {
                    //grab count of categories
                    store.get("products/rules/count");
                    jsonObject = new JSONObject(store.toString());
                    rulesCount = jsonObject.getInt("count");
                    store.get("products/count");
                    jsonObject = new JSONObject(store.toString());
                    productsCount = jsonObject.getInt("count");
                    newThread = new Thread(new ProgressThread(orphanedRulesProgress));
                    apiLimitThread = new Thread(new UpdateThread(desktop.getConnectivity()));
                    apiLimitThread.start();
                    newThread.start();
                } catch (IOException ex) {
                    System.out.println("Issue with the following: " + ex.getMessage());
                }
                currentTask = "Gathering Products";
                do {
                    try {
                        store.get("products?limit=249&page=" + page);
                        results = store.toString();
                        jsonArray = new JSONArray(results);
                        jsonArrayLength = jsonArray.length();
                        String sqlStatement = "INSERT INTO allProducts (prodID, prodName) " + 
                                              "VALUES(?,?);";
                        preparedStatement = database.prepareStatement(sqlStatement);
                        for(int index = 0; index < jsonArrayLength; index++) {
                            jsonObject = jsonArray.getJSONObject(index);
                            preparedStatement.setInt(1, jsonObject.getInt("id"));
                            preparedStatement.setString(2, jsonObject.getString("name"));
                            preparedStatement.executeUpdate();
                            percentage = (((index + 1 + (249 * (page - 1))) * 100) / productsCount);
                        }
                        if (jsonArrayLength == 249) page++;
                    } catch (IOException ex) {
                        System.out.println("Issue with the following: " + ex.getMessage());
                    }
                } while (jsonArrayLength == 249);
                percentage = 99;
                page = 1;
                currentTask = "Gathering Rules";
                percentage = 0;
                do {
                    try {
                        store.get("products/rules?limit=249&page=" + page);
                        results = store.toString();
                        jsonArray = new JSONArray(results);
                        jsonArrayLength = jsonArray.length();
                        int productID;
                        String prepstm = "INSERT INTO allRules (ruleid, prodid) " +
                                         "VALUES(?,?,?);";
                        preparedStatement = database.prepareStatement(prepstm);
                        for(int index = 0; index < jsonArrayLength; index++) {
                            jsonObject = jsonArray.getJSONObject(index);
                            if (jsonObject.get("product_id") instanceof Integer)
                                productID = jsonObject.getInt("product_id");
                            else
                                productID = -1;
                            preparedStatement.setInt(1, jsonObject.getInt("id"));
                            preparedStatement.setInt(3, productID);
                            preparedStatement.executeUpdate();
                            percentage = (((index + 1 + (249 * (page - 1))) * 100) / rulesCount);
                        }
                        if (jsonArrayLength == 249) page++;
                    } catch (IOException ex) {
                        System.out.println("Issue with the following: " + ex.getMessage());
                    }
                } while (jsonArrayLength == 249);
                database.commit();
                ResultSet counts = statement.executeQuery("SELECT COUNT(DISTINCT prodID) AS 'orphanedprods', COUNT(ruleid) AS 'orphanedrules'" +
                                                          "FROM allRules AS child " +
                                                          "WHERE NOT EXISTS " +
                                                          "(SELECT 1 FROM allProducts AS parent " +
                                                          "WHERE parent.prodid = child.prodid);");
                
                totalRules = 0;
                int totalProds = 0;
                while(counts.next()) {
                    totalRules = counts.getInt("orphanedrules");
                    totalProds = counts.getInt("orphanedprods");
                }
                if (totalRules > 0) {
                    orphanedRulesLabel.setText("<html>Total product IDs with orphaned rules: " + totalProds + "<br>" +
                                              "Total orphaned rules found: " + totalRules + "</html>");
                    orphanedRulesFix.setEnabled(true);
                }
                else {
                    orphanedRulesLabel.setText("No orphans found");
                }
                orphanedRulesCheck.setEnabled(true);
                return null;
            }
        };
        worker.execute();
    }//GEN-LAST:event_orphanedRulesCheckActionPerformed

    private void orphanedRulesFixActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_orphanedRulesFixActionPerformed
        SwingWorker <Void, Void> worker = new SwingWorker<Void, Void>() {
        @Override
            protected Void doInBackground() throws Exception {
                orphanedRulesFix.setEnabled(false);
                percentage = 0;
                int counter = 0;
                long starttimer;
                long timerSeconds;
                newThread = new Thread(new ProgressThread(orphanedRulesProgress, true));
                apiLimitThread = new Thread(new UpdateThread(desktop.getConnectivity()));
                apiLimitThread.start();
                newThread.start();
                currentTask = "Deleting Rules";
                Statement retrieveData = database.createStatement();
                retrieveData.setQueryTimeout(30);
                try {
                ResultSet orphanedRules = retrieveData.executeQuery("SELECT ruleid" +
                                                                "FROM allSKUs AS child " +
                                                                "WHERE NOT EXISTS " +
                                                                "(SELECT 1 FROM allProducts AS parent " +
                                                                "WHERE parent.prodid = child.prodid);");
                while (orphanedRules.next()) {
                    starttimer = System.nanoTime();
                    store.delete("products/rules/" + orphanedRules.getInt("ruleID"));
                    counter++;
                    percentage = (counter * 100) / totalRules;
                    timerSeconds = (System.nanoTime() - starttimer) * (totalRules - counter);
                    timer = "";
                    int day = (int) TimeUnit.NANOSECONDS.toDays(timerSeconds);
                    long hours = TimeUnit.NANOSECONDS.toHours(timerSeconds) - (day * 24);
                    long minute = TimeUnit.NANOSECONDS.toMinutes(timerSeconds) - (TimeUnit.NANOSECONDS.toHours(timerSeconds) * 60);
                    long second = TimeUnit.NANOSECONDS.toSeconds(timerSeconds) - (TimeUnit.NANOSECONDS.toMinutes(timerSeconds) *60);
                    if(day > 0) timer += day + "d ";
                    if(hours > 0) timer+= hours + "h ";
                    if(minute > 0) timer+= minute + "m ";
                    if(second > 0) timer+= second + "s ";
                }
                } catch (SQLException ex) {
                    System.out.println("Issue with the following: " + ex.getMessage());
                }
                retrieveData.close();
                return null;
            }
        };
        worker.execute();
    }//GEN-LAST:event_orphanedRulesFixActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton orphanedRulesCheck;
    private javax.swing.JButton orphanedRulesFix;
    private javax.swing.JLabel orphanedRulesLabel;
    private javax.swing.JProgressBar orphanedRulesProgress;
    // End of variables declaration//GEN-END:variables
}
